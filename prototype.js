// Generated by CoffeeScript 1.3.3
(function() {
  var animloop, ball, ctx, epoch, gravity, line, lines, mass, new_ball, new_velo, predict, radius, render, t_end, velo, x_max, x_min, y_max, y_min;

  ctx = document.getElementById('arena').getContext('2d');

  lines = [[10, 10, 10, 300], [10, 10, 300, 10], [10, 300, 300, 400], [300, 10, 300, 400], [100, 10, 200, 150]];

  lines = (function() {
    var _i, _len, _results;
    _results = [];
    for (_i = 0, _len = lines.length; _i < _len; _i++) {
      line = lines[_i];
      x_min = Math.min(line[0], line[2]);
      x_max = Math.max(line[0], line[2]);
      y_min = Math.min(line[1], line[3]);
      y_max = Math.max(line[1], line[3]);
      _results.push([x_min, y_min, x_max, y_max]);
    }
    return _results;
  })();

  radius = 5;

  ball = [50, 50];

  mass = 1;

  velo = [0, 18];

  gravity = 1;

  t_end = 0;

  new_velo = [];

  new_ball = [];

  predict = function() {
    var ball_angle, candidates, defl_angle, dx, dy, i, line_angle, magnitude, x, y, _i, _ref;
    candidates = (function() {
      var _i, _len, _results;
      _results = [];
      for (_i = 0, _len = lines.length; _i < _len; _i++) {
        line = lines[_i];
        t_end = (2 * line[1] * velo[0] - 2 * line[3] * velo[0] - 2 * line[0] * velo[1] + 2 * line[2] * velo[1] - Math.sqrt(-4 * (gravity * line[0] - gravity * line[2]) * (2 * ball[1] * line[0] - 2 * ball[0] * line[1] - 2 * ball[1] * line[2] + 2 * line[1] * line[2] + 2 * ball[0] * line[3] - 2 * line[0] * line[3]) + Math.pow(-2 * line[1] * velo[0] + 2 * line[3] * velo[0] + 2 * line[0] * velo[1] - 2 * line[2] * velo[1], 2))) / (2 * (gravity * line[0] - gravity * line[2]));
        y = 0.5 * gravity * t_end * t_end + velo[1] * t_end + ball[1];
        x = t_end * velo[0] + ball[0];
        ctx.fillRect(x - 3, y - 3, 6, 6);
        x_min = Math.min(line[0], line[2]);
        x_max = Math.max(line[0], line[2]);
        y_min = Math.min(line[1], line[3]);
        y_max = Math.max(line[1], line[3]);
        if (!((x_min <= x && x <= x_max) && (y_min <= y && y <= y_max))) {
          continue;
        }
        _results.push([t_end, x, y]);
      }
      return _results;
    })();
    if (candidates.length > 0) {
      _ref = candidates.sort(function(a, b) {
        return a[0] - b[0];
      })[0], t_end = _ref[0], x = _ref[1], y = _ref[2];
      dy = gravity * t_end + velo[1];
      dx = velo[0];
      line_angle = Math.atan2(line[3] - line[1], line[2] - line[0]);
      ball_angle = Math.atan2(dy, dx);
      defl_angle = -line_angle;
      magnitude = Math.sqrt(dy * dy + dx * dx);
      for (i = _i = 0; _i <= 100; i = ++_i) {
        ctx.fillRect(x + i * Math.cos(defl_angle), y + i * Math.sin(defl_angle), 1, 1);
      }
      new_velo = [magnitude * Math.cos(defl_angle), magnitude * Math.sin(defl_angle)];
      return new_ball = [x, y];
    }
  };

  /*ctx.beginPath()
  ctx.moveTo(x, 0)
  ctx.lineTo(x, 1000)
  ctx.stroke()
  
  ctx.beginPath()
  ctx.moveTo(0, y)
  ctx.lineTo(1000, y)
  ctx.stroke() 
  console.log t
  */


  epoch = +(new Date);

  render = function() {
    var t, x, y, _i, _len;
    ctx.clearRect(0, 0, 1000, 1000);
    ctx.beginPath();
    for (_i = 0, _len = lines.length; _i < _len; _i++) {
      line = lines[_i];
      ctx.moveTo(line[0], line[1]);
      ctx.lineTo(line[2], line[3]);
    }
    ctx.stroke();
    t = 10 * (new Date - epoch) / 1000;
    predict();
    if (t >= t_end) {
      t = t_end;
      epoch = +(new Date);
      velo = new_velo;
      ball = new_ball;
    }
    y = 0.5 * gravity * t * t + velo[1] * t + ball[1];
    x = t * velo[0] + ball[0];
    ctx.beginPath();
    ctx.moveTo(x + radius, y);
    ctx.arc(x, y, radius, 0, Math.PI * 2, false);
    return ctx.stroke();
  };

  animloop = function() {
    requestAnimFrame(animloop);
    return render();
  };

  predict();

  animloop();

}).call(this);
