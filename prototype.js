// Generated by CoffeeScript 1.3.3
(function() {
  var absepoch, addCircle, animloop, ball, ctx, epoch, gravity, lines, mass, new_ball, new_velo, predict, radius, render, t_end, velo;

  ctx = document.getElementById('arena').getContext('2d');

  /*
  radius = 5
  line = [300, 10, 300, 400]
  ball = [50, 50]
  mass = 1
  velo = [18, 0]
  gravity = 1
  
  ctx.beginPath()
  ctx.moveTo line[0], line[1]
  ctx.lineTo line[2], line[3]
  ctx.stroke()
  
  ctx.beginPath()
  ctx.moveTo ball[0], ball[1]
  for t in [0..100]
  	y = 0.5 * gravity * t * t + velo[1] * t + ball[1]
  	x = t * velo[0] + ball[0]
  	ctx.lineTo x, y
  ctx.stroke()
  
  
  
  A = line[3] - line[1]
  B = line[0] - line[2]
  C = line[0] * line[3] - line[1] * line[2]
  
  console.log A, B, C
  if B == 0
  	t = -((-C + A * ball[0])/(A * velo[0]))
  else
  	t = (-2 * A * velo[0] - 2 * B * velo[1] + Math.sqrt(-8 * B * gravity * (-C + A * ball[0] + B * ball[1]) + 4 * Math.pow(A * velo[0] + B * velo[1],2)))/(2 * B *gravity)
  
  console.log t
  */


  /*
  a = 2 * line[1] * velo[0] - 2 * line[3] * velo[0] - 2 * line[0] * velo[1] + 2 * line[2] * velo[1]
  b = Math.sqrt(-4 * (gravity * line[0] - 
            gravity * line[2]) * (2 * ball[1] * line[0] - 2 * ball[0] * line[1] - 
            2 * ball[1] * line[2] + 2 * line[1] * line[2] + 2 * ball[0] * line[3] - 
            2 * line[0] * line[3]) + Math.pow(-2 * line[1] * velo[0] + 
           2 * line[3] * velo[0] + 2 * line[0] * velo[1] - 
           2 * line[2] * velo[1], 2))
  c = (2 * (gravity * line[0] - gravity * line[2]))
  
  t_end = (a + b)/c
  console.log (a - b)/c
  */


  /*
  t_end = (2 * line[1] * velo[0] - 2 * line[3] * velo[0] - 2 * line[0] * velo[1] + 
      2 * line[2] * velo[1] + Math.sqrt(-4 * (gravity * line[0] - 
            gravity * line[2]) * (2 * ball[1] * line[0] - 2 * ball[0] * line[1] - 
            2 * ball[1] * line[2] + 2 * line[1] * line[2] + 2 * ball[0] * line[3] - 
            2 * line[0] * line[3]) + Math.pow(-2 * line[1] * velo[0] + 
           2 * line[3] * velo[0] + 2 * line[0] * velo[1] - 
           2 * line[2] * velo[1], 2)))/(2 * (gravity * line[0] - 
        gravity * line[2]))
  
  t_end = t
  console.log t_end
  
  y = 0.5 * gravity * t_end * t_end + velo[1] * t_end + ball[1]
  x = t_end * velo[0] + ball[0]
  
  ctx.beginPath()
  ctx.moveTo(x + radius, y);
  ctx.arc(x, y, radius, 0, Math.PI*2, false);
  ctx.stroke()
  */


  lines = [[30, 30, 30, 300], [30, 30, 350, 30], [30, 300, 300, 400], [350, 30, 350, 450], [30, 450, 350, 450], [300, 60, 300, 400], [100, 30, 200, 150]];

  addCircle = function(x, y, rad) {
    var seg, slice, _i, _ref, _results;
    slice = Math.PI / 16;
    _results = [];
    for (seg = _i = 0, _ref = Math.PI * 2; 0 <= _ref ? _i <= _ref : _i >= _ref; seg = _i += slice) {
      _results.push(lines.push([x + (rad * Math.cos(seg)), y + (rad * Math.sin(seg)), x + (rad * Math.cos(seg + slice)), y + (rad * Math.sin(seg + slice))]));
    }
    return _results;
  };

  addCircle(200, 200, 40);

  radius = 5;

  ball = [50, 50];

  mass = 1;

  velo = [0, 18];

  gravity = 1;

  t_end = 0;

  new_velo = [];

  new_ball = [];

  this.energy = 0;

  this.enerplier = 1;

  predict = function() {
    var A, B, C, a, b, ball_angle, candidates, defl_angle, det, dx, dy, line, line_angle, magnitude, x, x_max, x_min, y, y_max, y_min, _ref;
    candidates = (function() {
      var _i, _len, _results;
      _results = [];
      for (_i = 0, _len = lines.length; _i < _len; _i++) {
        line = lines[_i];
        A = line[3] - line[1];
        B = line[0] - line[2];
        C = line[0] * line[3] - line[1] * line[2];
        if (B === 0) {
          t_end = -((-C + A * ball[0]) / (A * velo[0]));
        } else {
          det = Math.sqrt(-8 * B * gravity * (-C + A * ball[0] + B * ball[1]) + 4 * Math.pow(A * velo[0] + B * velo[1], 2));
          a = (-2 * A * velo[0] - 2 * B * velo[1] + det) / (2 * B * gravity);
          b = (-2 * A * velo[0] - 2 * B * velo[1] - det) / (2 * B * gravity);
          if (a > 0 && b > 0) {
            t_end = Math.min(a, b);
          } else {
            t_end = Math.max(a, b);
          }
        }
        y = 0.5 * gravity * t_end * t_end + velo[1] * t_end + ball[1];
        x = t_end * velo[0] + ball[0];
        x_min = Math.min(line[0], line[2]) - 1;
        x_max = Math.max(line[0], line[2]) + 1;
        y_min = Math.min(line[1], line[3]) - 1;
        y_max = Math.max(line[1], line[3]) + 1;
        if (!((x_min <= x && x <= x_max) && (y_min <= y && y <= y_max))) {
          continue;
        }
        if (isNaN(t_end) || !isFinite(t_end) || t_end < 0.1) {
          continue;
        }
        _results.push([t_end, x, y, line]);
      }
      return _results;
    })();
    if (candidates.length > 0) {
      _ref = candidates.sort(function(a, b) {
        return a[0] - b[0];
      })[0], t_end = _ref[0], x = _ref[1], y = _ref[2], line = _ref[3];
      dy = gravity * t_end + velo[1];
      dx = velo[0];
      line_angle = Math.atan2(line[3] - line[1], line[2] - line[0]);
      ball_angle = Math.atan2(dy, dx);
      defl_angle = 2 * line_angle - ball_angle;
      magnitude = Math.sqrt(dy * dy + dx * dx) * enerplier;
      this.energy = 0.5 * mass * magnitude * magnitude - mass * gravity * y;
      new_velo = [magnitude * Math.cos(defl_angle), magnitude * Math.sin(defl_angle)];
      return new_ball = [x, y];
    } else {
      new_velo = velo;
      return new_ball = [60, 60];
    }
  };

  /*
  ctx.beginPath()
  ctx.moveTo(x, 0)
  ctx.lineTo(x, 1000)
  ctx.stroke()
  
  ctx.beginPath()
  ctx.moveTo(0, y)
  ctx.lineTo(1000, y)
  ctx.stroke() 
  console.log t
  */


  absepoch = +(new Date);

  epoch = +(new Date);

  this.timecoef = 1;

  this.baseline = 0;

  this.setSpeed = function(speed) {
    var t;
    t = timecoef * (new Date - epoch) / 1000;
    this.timecoef = speed;
    return epoch = (+(new Date)) - 1000 * t / timecoef;
  };

  render = function() {
    var line, t, x, y, _i, _len;
    ctx.clearRect(0, 0, 1000, 1000);
    ctx.fillRect(100, 0, 1e14 * (energy - baseline), 5);
    ctx.beginPath();
    for (_i = 0, _len = lines.length; _i < _len; _i++) {
      line = lines[_i];
      ctx.moveTo(line[0], line[1]);
      ctx.lineTo(line[2], line[3]);
    }
    ctx.stroke();
    t = timecoef * (new Date - epoch) / 1000;
    y = 0.5 * gravity * t * t + velo[1] * t + ball[1];
    x = t * velo[0] + ball[0];
    predict();
    if (t >= t_end) {
      t = t_end;
      y = 0.5 * gravity * t * t + velo[1] * t + ball[1];
      x = t * velo[0] + ball[0];
      epoch = +(new Date);
      velo = new_velo;
      ball = new_ball;
    }
    ctx.beginPath();
    ctx.moveTo(x + radius, y);
    ctx.arc(x, y, radius, 0, Math.PI * 2, false);
    return ctx.stroke();
  };

  animloop = function() {
    requestAnimFrame(animloop);
    return render();
  };

  predict();

  animloop();

}).call(this);
